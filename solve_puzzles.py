#!/usr/bin/env python3
#
# basic framework generated by claude but then heavily tweaked
# jbum added timing and solution counting

import sys
import time
import argparse
from draw_limesudoku import draw_puzzle
import importlib
from puzzle_record import PuzzleRecord

def read_puzzles_from_file(filename, args):
    """
    Read puzzles from a test suite file.
    
    Args:
        filename: Path to the test suite file
    
    Returns:
        List of tuples (puzzle_string, comment)
    """
    puzzles = []
    
    try:
        with open(filename, 'r') as file:
            for line_num, line in enumerate(file, 1):
                line = line.strip()
                
                # Skip empty lines and comment-only lines
                if not line or line.startswith('#'):
                    continue

                puzrec = PuzzleRecord.parse_puzzle(line)

                puzzles.append(puzrec)
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return []
    except Exception as e:
        print(f"Error reading file '{filename}': {e}")
        import traceback
        traceback.print_exc()
        return []
    if args.verbose:
        print(f"Found {len(puzzles)} puzzles in {filename}")
    return puzzles

def solve_puzzles_from_file(filename, args):
    """
    Solve all puzzles from a test suite file.
    
    Args:
        filename: Path to the test suite file
        args: Command-line arguments
    """
    puzzles = read_puzzles_from_file(filename, args)
    
    if not puzzles:
        print("No valid puzzles found in the file.")
        return
    
    if args.verbose:
        print(f"Found {len(puzzles)} puzzles to solve.\n")
    nbr_solved = 0
    nbr_encountered = 0
    branches_encountered = 0

    start_time = time.perf_counter()
    for i, puzrec in enumerate(puzzles, 1):
        puzzle_str = puzrec.clues_string
        annotations = puzrec.annotations
        answer_str = puzrec.answer_string
        nom = puzrec.nom
        ptype = puzrec.puzzle_type

        if i < args.puzzle_offset:
            continue

        if args.verbose:
            print(f"Puzzle {i}:")
            print(f"  Puzzle: {puzzle_str}")
            if comment:
                print(f"  Comment: {comment}")

        nbr_encountered += 1
        
        answer,stats = solve(puzrec, options={'draw_steps':args.draw_steps, 
                                    'bestiary_draw':args.bestiary_draw,
                                    'inhibit_annotations':args.inhibit_annotations,
                                    'verbose':args.verbose, 
                                    'very_verbose': args.very_verbose,
                                    'max_tier':args.max_tier, 
                                    'draw_unsolved':args.draw_unsolved})

        if answer is None:
            print(f"ERROR: no answer found for puzzle {i}")
            print(f"  Puzzle: {puzzle_str}")
            print(f"  Annotations: {annotations}")
            sys.exit(1)

        if len(answer) == 81:
            if answer_str != None and answer != answer_str:
                print(f"ERROR: answer mismatch for puzzle {i}")
                print(f"  Expected: {answer_str}")
                print(f"  Got: {answer}")
                sys.exit(1)

            nbr_solved += 1
            branches_encountered += stats['branches'] if 'branches' in stats else 0

            if args.average_branch_count:
                if args.solver != 'OR':
                    print("ERROR: average_branch_count is only supported for OR solver")
                    sys.exit(1)
                tot_solved = 1
                tot_branch_count = stats['branches']
                for r in range(1,5):
                    _,stats = solve(puzzle_str, options={'rand_seed':r})
                    tot_solved += 1
                    tot_branch_count += stats['branches']
                avg_branch_count = tot_branch_count / tot_solved
                stats['abc'] = avg_branch_count

            if args.draw_puzzle:
                print("drawing puzzle ", puzzle_str)
                draw_puzzle(f"drawings/puzzle_{i}.png", puzzle_str, layout_string=layout, answer_string=None, annotation=f"Puzzle #{i}")

            if args.print_puzzles or args.average_branch_count:
                print(puzrec)
                # print(f"{nom}\t{ptype}{'\t'+layout if layout else ''}\t{puzzle_str}\t{answer}\t{stats}")

        if args.verbose:
            print(f"  Result: {answer}")
            print()

        if args.number_to_solve and nbr_encountered >= args.number_to_solve:
            break

    end_time = time.perf_counter()
    elapsed_microseconds = int((end_time - start_time) * 1_000_000)
    print(f"# {nbr_solved}/{len(puzzles)} puzzles solved in {elapsed_microseconds/1000000:.3f} seconds.")
    if branches_encountered > 0:
        print(f"# {branches_encountered} branches encountered")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Solve puzzles from a test suite file.')
    parser.add_argument('filename', type=str, help='Path to the test suite file')
    parser.add_argument('--rand_seed', type=int, default=None, help='Random seed for the solver')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-vv', '--very_verbose', action='store_true', help='Enable very verbose output (implies --verbose)')
    parser.add_argument('-ofst', '--puzzle_offset', type=int, default=1, help='Index of first puzzle to solve (1-based)')
    parser.add_argument('-n', '--number_to_solve', type=int, default=None, help='Number of puzzles to solve (default: all)')
    parser.add_argument('-abc', '--average_branch_count', action='store_true', help='Show average branch count statistics')
    parser.add_argument('-dp', '--draw_puzzle', action='store_true', help='Draw the solved puzzles')
    parser.add_argument('-du', '--draw_unsolved', action='store_true', help='Draw the unsolved puzzles')
    parser.add_argument('-ds', '--draw_steps', action='store_true', help='Draw the solution steps')
    parser.add_argument('-bd', '--bestiary_draw', action='store_true', help='Bestiary drawing style for -ds (before/after steps)')
    parser.add_argument('-ia', '--inhibit_annotations', action='store_true', help='Do not include text labels in drawings')
    parser.add_argument('-s', '--solver', type=str, default='PR', choices=['OR', 'PR'], help='Solver to use (%(choices)s) (default: %(default)s)')
    parser.add_argument('-pp', '--print_puzzles', action='store_true', help='Print the solved puzzles')
    parser.add_argument('-maxt', '--max_tier', type=int, 
                        help='Maximum tier of rules to use in the solver (default: no limit)')
    parser.add_argument('-pt', '--puzzle_type', type=str, default='lime', choices=['lime', 'jiggy9'], help='Puzzle type (%(choices)s) (default: %(default)s)')
    args = parser.parse_args()

    if args.draw_steps and args.number_to_solve != 1:
        print("ERROR: -ds is only supported for a single puzzle, use -n 1")
        sys.exit(1)

    if args.very_verbose:
        args.verbose = True

    solver_module = importlib.import_module(f'solve_{args.solver}')
    solve = solver_module.solve


    solve_puzzles_from_file(args.filename, args)