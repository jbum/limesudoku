#!/usr/bin/env python3
#
# basic framework generated by claude but then heavily tweaked
# jbum added timing and solution counting

import sys
import time
import argparse
from draw_limesudoku import draw_puzzle
import importlib


def read_puzzles_from_file(filename):
    """
    Read puzzles from a test suite file.
    
    Args:
        filename: Path to the test suite file
    
    Returns:
        List of tuples (puzzle_string, comment)
    """
    puzzles = []
    
    try:
        with open(filename, 'r') as file:
            for line_num, line in enumerate(file, 1):
                line = line.strip()
                
                # Skip empty lines and comment-only lines
                if not line or line.startswith('#'):
                    continue

                parts = line.split('\t')
                nom = parts[0]
                parts = parts[1:]
                ptype = parts[0]
                parts = parts[1:]
                if 'jiggy' in ptype:
                    layout = parts[0]
                    parts = parts[1:]
                else:
                    layout = None
                puzzle_str = parts[0]
                parts = parts[1:]
                answer_str = parts[0]
                comment = 'ans='+answer_str

                # # old format
                # # Split on '#' to separate puzzle from comment
                # parts = line.split('#', 1)
                # puzzle_str = parts[0].strip()
                # comment = parts[1].strip() if len(parts) > 1 else ""
                # answer_str = parts[1][1:82]
                # layout = None

                # Validate puzzle string length (should be 81 characters)
                if len(puzzle_str) != 81:
                    print(f"Warning: Line {line_num} has invalid puzzle length {len(puzzle_str)}, skipping")
                    continue
                
                # Validate puzzle string contains only valid characters
                valid_chars = set('.012345678')
                if not all(c in valid_chars for c in puzzle_str):
                    print(f"Warning: Line {line_num} contains invalid characters, skipping")
                    continue
                
                puzzles.append({'puzzle':puzzle_str, 'comment':comment, 'answer':answer_str, 'layout':layout, 'ptype':ptype, 'nom':nom})
                
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return []
    except Exception as e:
        print(f"Error reading file '{filename}': {e}")
        return []
    
    return puzzles

def solve_puzzles_from_file(filename, args):
    """
    Solve all puzzles from a test suite file.
    
    Args:
        filename: Path to the test suite file
        args: Command-line arguments
    """
    puzzles = read_puzzles_from_file(filename)
    
    if not puzzles:
        print("No valid puzzles found in the file.")
        return
    
    if args.verbose:
        print(f"Found {len(puzzles)} puzzles to solve.\n")
    nbr_solved = 0
    nbr_encountered = 0
    branches_encountered = 0
    max_subgroup_split_depth = 0

    start_time = time.perf_counter()
    for i, puzrec in enumerate(puzzles, 1):
        puzzle_str = puzrec['puzzle']
        comment = puzrec['comment']
        answer_str = puzrec['answer']
        layout = puzrec['layout']
        nom = puzrec['nom']
        ptype = puzrec['ptype']

        if i < args.puzzle_offset:
            continue

        if args.verbose:
            print(f"Puzzle {i}:")
            print(f"  Puzzle: {puzzle_str}")
            if comment:
                print(f"  Comment: {comment}")

        nbr_encountered += 1
        
        answer,stats = solve(puzzle_str, known_answer_str=answer_str, 
                            options={'draw_steps':args.draw_steps, 
                                    'verbose':args.verbose, 
                                    'max_tier':args.max_tier, 
                                    'layout':layout,
                                    'draw_unsolved':args.draw_unsolved,
                                    'nom':nom,
                                    'ptype':ptype})

        if answer is None:
            print(f"ERROR: no answer found for puzzle {i}")
            print(f"  Puzzle: {puzzle_str}")
            print(f"  Comment: {comment}")
            sys.exit(1)

        if len(answer) == 81:
            if answer_str != None and answer != answer_str:
                print(f"ERROR: answer mismatch for puzzle {i}")
                print(f"  Expected: {answer_str}")
                print(f"  Got: {answer}")
                sys.exit(1)

            nbr_solved += 1
            branches_encountered += stats['branches'] if 'branches' in stats else 0
            max_subgroup_split_depth = max(max_subgroup_split_depth, stats['max_subgroup_split_depth'] if 'max_subgroup_split_depth' in stats else 0)

            if args.average_branch_count:
                if args.solver != 'OR':
                    print("ERROR: average_branch_count is only supported for OR solver")
                    sys.exit(1)
                tot_solved = 1
                tot_branch_count = stats['branches']
                for r in range(1,5):
                    _,stats = solve(puzzle_str, options={'rand_seed':r})
                    tot_solved += 1
                    tot_branch_count += stats['branches']
                avg_branch_count = tot_branch_count / tot_solved
                stats['abc'] = avg_branch_count

            if args.draw_puzzle:
                print("drawing puzzle ", puzzle_str)
                draw_puzzle(f"drawings/puzzle_{i}.png", puzzle_str, None, annotation=f"Puzzle #{i}")

            if args.print_puzzles or args.average_branch_count:
                print(f"{nom}\t{ptype}{'\t'+layout if layout else ''}\t{puzzle_str}\t{answer}\t{stats}")

        if args.verbose:
            print(f"  Result: {answer}")
            print()

        if args.number_to_solve and nbr_encountered >= args.number_to_solve:
            break

    end_time = time.perf_counter()
    elapsed_microseconds = int((end_time - start_time) * 1_000_000)
    print(f"# {nbr_solved}/{len(puzzles)} puzzles solved in {elapsed_microseconds/1000000:.3f} seconds.")
    print(f"# {branches_encountered} branches encountered")
    print(f"# {max_subgroup_split_depth} max subgroup split depth")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Solve puzzles from a test suite file.')
    parser.add_argument('filename', type=str, help='Path to the test suite file')
    parser.add_argument('--rand_seed', type=int, default=None, help='Random seed for the solver')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-vv', '--very_verbose', action='store_true', help='Enable very verbose output (implies --verbose)')
    parser.add_argument('-ofst', '--puzzle_offset', type=int, default=1, help='Index of first puzzle to solve (1-based)')
    parser.add_argument('-n', '--number_to_solve', type=int, default=None, help='Number of puzzles to solve (default: all)')
    parser.add_argument('-abc', '--average_branch_count', action='store_true', help='Show average branch count statistics')
    parser.add_argument('-dp', '--draw_puzzle', action='store_true', help='Draw the solved puzzles')
    parser.add_argument('-du', '--draw_unsolved', action='store_true', help='Draw the unsolved puzzles')
    parser.add_argument('-ds', '--draw_steps', action='store_true', help='Draw the solution steps')
    parser.add_argument('-s', '--solver', type=str, default='OR', help='Solver to use (OR, PR)')
    parser.add_argument('-pp', '--print_puzzles', action='store_true', help='Print the solved puzzles')
    parser.add_argument('-maxt', '--max_tier', type=int, 
                        help='Maximum tier of rules to use in the solver (default: no limit)')
    args = parser.parse_args()

    if args.draw_steps and args.number_to_solve != 1:
        print("ERROR: -ds is only supported for a single puzzle, use -n 1")
        sys.exit(1)

    if args.very_verbose:
        args.verbose = True

    solver_module = importlib.import_module(f'solve_{args.solver}')
    solve = solver_module.solve


    solve_puzzles_from_file(args.filename, args)